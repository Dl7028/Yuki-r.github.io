<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一、学习脑图">
<meta property="og:type" content="article">
<meta property="og:title" content="View体系详解">
<meta property="og:url" content="http://example.com/2020/09/26/View%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/index.html">
<meta property="og:site_name" content="Yuki-r Blog">
<meta property="og:description" content="一、学习脑图">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926223547.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925173603.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925000114.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200921183656.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200921202114.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925171330.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925171402.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926222121.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926222140.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926180448.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926204216.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926215641.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925225449.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925230015.png">
<meta property="article:published_time" content="2020-09-26T14:40:02.000Z">
<meta property="article:modified_time" content="2020-09-26T14:40:32.947Z">
<meta property="article:author" content="Yuki">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926223547.png">

<link rel="canonical" href="http://example.com/2020/09/26/View%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>View体系详解 | Yuki-r Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yuki-r Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/26/View%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/suoda.jpg">
      <meta itemprop="name" content="Yuki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuki-r Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          View体系详解
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-26 22:40:02 / 修改时间：22:40:32" itemprop="dateCreated datePublished" datetime="2020-09-26T22:40:02+08:00">2020-09-26</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="一、学习脑图"><a href="#一、学习脑图" class="headerlink" title="一、学习脑图"></a>一、学习脑图</h2><p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926223547.png"></p>
<a id="more"></a>

<h2 id="二、View基础"><a href="#二、View基础" class="headerlink" title="二、View基础"></a>二、View基础</h2><p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925173603.png"></p>
<h3 id="2-1-什么是View？"><a href="#2-1-什么是View？" class="headerlink" title="2.1 什么是View？"></a>2.1 什么是<code>View</code>？</h3><p>Q1：怎么理解<code>View</code>？</p>
<blockquote>
<ul>
<li><code>View</code>是界面层的控件的一种抽象，代表了一个控件。</li>
<li>是<code>android</code>在视觉上的呈现。</li>
<li>是所有控件是基类，可以是单个控件<code>View</code>可以是一组控件<code>ViewGroup</code>。</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925000114.png"></p>
<p>Q2：<code>View</code>的重要性？</p>
<blockquote>
<p><code>View</code>在<code>Android</code>中是一个十分重要的概念，虽然说<code>View</code>不属于四大组件，但是它的作用堪比四大组件，在开发中，<code>Activity</code>承担了可视化的功能，<code>Android</code>提供了很多基础的控件，当我们不满足于这些基础控件的功能时，可以用自定义控件，而控件的自定义就需要对<code>View</code>体系有深入的了解。</p>
</blockquote>
<h3 id="2-2-View的位置参数"><a href="#2-2-View的位置参数" class="headerlink" title="2.2 View的位置参数"></a>2.2 <code>View</code>的位置参数</h3><blockquote>
<p><code>Android</code>系统中，有两种坐标系，分别是<code>Android</code>坐标系和<code>View</code>坐标系。</p>
</blockquote>
<h5 id="2-2-1-Android坐标系"><a href="#2-2-1-Android坐标系" class="headerlink" title="2.2.1 Android坐标系"></a>2.2.1 <code>Android</code>坐标系</h5><blockquote>
<ul>
<li>将屏幕左上角作为坐标原点</li>
<li>原点向右是X轴正方向</li>
<li>原点向下是Y轴正方向</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200921183656.png"></p>
<blockquote>
<p>注意：使用<code>getRawX()</code>和<code>getRawY()</code>方法获得的坐标是Android坐标系的坐标</p>
</blockquote>
<h5 id="2-2-2-View坐标系"><a href="#2-2-2-View坐标系" class="headerlink" title="2.2.2 View坐标系"></a>2.2.2 <code>View</code>坐标系</h5><p>Q1:<code>View</code>的位置由什么来决定？</p>
<p>四个顶点：<code>top</code>（左上角纵坐标）、<code>left</code>（左上角横坐标）、<code>right</code>（右下角横坐标）、<code>bottom</code>（右下角纵坐标）</p>
<blockquote>
<p>注意：这些坐标都是相对于父容器来说的，是一种相对坐标</p>
<p><code>Top = getTop()</code>，<code>Left = getLeft()</code>,<code>Right = getRight()</code>,<code>Bottom=getBottom()</code></p>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200921202114.png"></p>
<blockquote>
<p>自Anroid3.0后，增加了<code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>这几个参数。</p>
<ul>
<li><code>x</code>、<code>y</code>：<code>View</code>左上角的坐标</li>
<li><code>translationX</code>、<code>translationY</code>：左上角相对于父容器的偏移量</li>
</ul>
</blockquote>
<p>注意：<code>View</code>在平移过程中，<code>top</code>和<code>left</code>表示原始左上角的位置信息，发生改变的值是<code>x</code>、<code>y</code>、<code>translationX</code>、<code>translationY</code>这四个参数。</p>
<p>Q2：<code>getX()</code>、<code>getY()</code>和<code>getRawX()</code>、<code>getRawY()</code>有什么区别？</p>
<blockquote>
<p><code>getX</code>和<code>getY</code>是视图坐标，是相对于控件的距离</p>
<p><code>getRawX</code>和<code>getRawY</code>是绝对坐标，是与整个屏幕的距离</p>
</blockquote>
<p>Q3：<code>View</code>怎么获取自身的宽和高？</p>
<blockquote>
<p><code>width</code> = <code>getRight()</code>-<code>getLeft()</code> = <code>getWidth()</code></p>
<p><code>height</code> = <code>getBottom()</code>-<code>getTop()</code> = <code>getHeight()</code> </p>
</blockquote>
<h5 id="2-2-3-View的触控"><a href="#2-2-3-View的触控" class="headerlink" title="2.2.3  View的触控"></a>2.2.3  <code>View</code>的触控</h5><h6 id="2-2-3-1-MotionEvent"><a href="#2-2-3-1-MotionEvent" class="headerlink" title="2.2.3.1 MotionEvent"></a>2.2.3.1 <code>MotionEvent</code></h6><blockquote>
<p>手指接触屏幕后所产生的一系列事件。</p>
</blockquote>
<ul>
<li><code>ACTION_DOWN</code> —— 手指刚接触屏幕</li>
<li><code>ACTION_MOVE</code> —— 手指在屏幕上移动</li>
<li><code>ACTION_UP</code> —— 手指从屏幕上松开的一瞬间</li>
</ul>
<blockquote>
<p>正常情况下，触摸屏幕会出现以下两种情况</p>
<ul>
<li>点击屏幕后松开，DOWN -&gt; UP</li>
<li>点击屏幕滑动后再松开，DOWN-&gt;MOVE-&gt;…-&gt;MOVE-&gt;UP</li>
</ul>
</blockquote>
<h6 id="2-2-3-2-TouchSlop"><a href="#2-2-3-2-TouchSlop" class="headerlink" title="2.2.3.2 TouchSlop"></a>2.2.3.2 <code>TouchSlop</code></h6><blockquote>
<p><code>TouchSlop</code>是系统所能识别出的被认为是滑动的最小距离,是一个常量。</p>
</blockquote>
<p>Q1：怎么获取这个常量？</p>
<p><code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>。</p>
<p>Q2：这个常量有什么意义？</p>
<p>在处理滑动时，可以利用这个常量来进行过滤，当两次滑动事件的滑动距离小于这个常量时，可以认为它们不是滑动。</p>
<h6 id="2-2-3-3-VelocityTracker"><a href="#2-2-3-3-VelocityTracker" class="headerlink" title="2.2.3.3 VelocityTracker"></a>2.2.3.3 <code>VelocityTracker</code></h6><blockquote>
<p>速度追踪，用于追踪手指在滑动过程中的速度，包括水平和竖直速度。</p>
</blockquote>
<p>Q：怎么使用<code>VelocityTracker</code>？</p>
<p>1.在<code>View</code>的<code>onTouchEvent</code>方法中追踪当前点击事件的速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VelocityTracker velocityTracker &#x3D; VelocityTracker.obtain(); </span><br><span class="line">velocityTracker.addMovement(event);</span><br></pre></td></tr></table></figure>

<p>2.获取当前速度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">velocityTracker.computeCurrentVelocity(1000);</span><br><span class="line">      int xVelocity &#x3D; (int)velocityTracker.getXVelocity();</span><br><span class="line">      int yVelocity &#x3D; (int)velocityTracker.getYVelocity();</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<blockquote>
<ul>
<li><p>获取速度之前需要先计算速度，即<code>getXVelocity()</code>和<code>getYVelocity()</code>方法前必须先调用<code>velocityTracker.computeCurrentVelocity(1000)</code>;</p>
</li>
<li><p>这里的速度指的事一段时间内手滑动的像素数。速度可以为正也可以为负，因为在<code>Android</code>坐标系中，手指逆着坐标正方向滑动，速度结果就是负的，这里的正负指的是方向。</p>
<p><strong>速度 = （终点位置 - 起点位置）/时间段</strong></p>
</li>
</ul>
</blockquote>
<p>3.使用<code>clear</code>重置并回收内存</p>
<p>当不需要使用<code>velocityTracker</code>时，需要使用<code>clear</code>去回收它。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">velocityTracker.clear();</span><br><span class="line">     velocityTracker.recycle();</span><br></pre></td></tr></table></figure>

<h6 id="2-2-3-4-GestureDetector"><a href="#2-2-3-4-GestureDetector" class="headerlink" title="2.2.3.4 GestureDetector"></a>2.2.3.4 <code>GestureDetector</code></h6><blockquote>
<p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。</p>
</blockquote>
<p>Q：怎么使用<code>GestureDetector</code>？</p>
<p>1.创建一个<code>GestureDetector</code>对象并实现<code>OnGestureDetector</code>接口</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GestureDetector mGestureDetector &#x3D; new GestureDetector(this,this);</span><br><span class="line">       &#x2F;&#x2F;解决长按屏幕后无法拖动的现象</span><br><span class="line"> mGestureDetector.setIsLongpressEnabled(false);</span><br></pre></td></tr></table></figure>

<p>2.在<code>View</code>的<code>onTouchEvent</code>方法添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">boolean consume &#x3D; mGestureDetector.onTouchEvent(event);</span><br><span class="line">       return consume;</span><br></pre></td></tr></table></figure>

<p>3.有选择的实现<code>OnGestureListener</code>和<code>OnDoubleTapListener</code>中的方法</p>
<blockquote>
<p>建议：如果只是监听滑动操作，建议在<code>onTouchEvent</code>中实现；如果要监听双击这种行为，则使用<code>GestureDetector</code> 。</p>
</blockquote>
<h6 id="2-2-3-5-Scroller"><a href="#2-2-3-5-Scroller" class="headerlink" title="2.2.3.5 Scroller"></a>2.2.3.5 <code>Scroller</code></h6><blockquote>
<p>弹性滑动对象，用于实现View的弹性滑动</p>
</blockquote>
<p>Q：如何使用<code>Scroller</code>？典型代码固定，如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Scroller scroller &#x3D; new Scroller(mContext);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;缓慢滚动到指定位置</span><br><span class="line">    private void smoothScrollTo(int destX,int destY)&#123;</span><br><span class="line">        int scrollX &#x3D; getScrollX();</span><br><span class="line">        int delta &#x3D; destX -scrollX;</span><br><span class="line">        &#x2F;&#x2F;1000ms内滑向destX，效果就是慢慢滑动</span><br><span class="line">        scroller.startScroll(scrollX,0,delta,0,1000);</span><br><span class="line">        invalidate;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Override</span><br><span class="line">    Public void computeScroll()&#123;</span><br><span class="line">    	if(mScroller.computeScrollOffset())&#123;</span><br><span class="line">    		ScrollTo(mScroll.getCurrX(),mScroller.getCurrY());</span><br><span class="line">    		postInvalidate();</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="三、View的滑动"><a href="#三、View的滑动" class="headerlink" title="三、View的滑动"></a>三、View的滑动</h2><blockquote>
<p>滑动在<code>Android</code>开发中具有重要的作用，掌握滑动的方法是实现自定义控件的基础。</p>
<p><code>View</code>滑动的基本思想:</p>
<p>当触摸事件传到<code>View</code>时，系统记下触摸点的坐标，手指移动时系统记下移动后的触摸的坐标并算出偏移量，并通过偏移量来修改<code>View</code>的坐标。</p>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925171330.png"></p>
<h3 id="3-1-View滑动的7种方法"><a href="#3-1-View滑动的7种方法" class="headerlink" title="3.1 View滑动的7种方法"></a>3.1 View滑动的7种方法</h3><h4 id="3-2-1-layout"><a href="#3-2-1-layout" class="headerlink" title="3.2.1 layout()"></a>3.2.1 <code>layout()</code></h4><blockquote>
<p> 思路：<code>view</code>进行绘制的时候会调用<code>onLayout()</code>方法来设置显示的位置，因此可以通过修改<code>View</code>的<code>left</code>、<code>top</code>、<code>right</code>、<code>bottom</code>这四种属性来控制<code>View</code>的坐标。</p>
</blockquote>
<ul>
<li>使用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       &#x2F;&#x2F;获取到手指处的横坐标和纵坐标</span><br><span class="line">       int x &#x3D; (int) event.getX();</span><br><span class="line">       int y &#x3D; (int) event.getY();</span><br><span class="line">       switch (event.getAction()) &#123;</span><br><span class="line">           case MotionEvent.ACTION_DOWN:</span><br><span class="line">               lastX &#x3D; x;</span><br><span class="line">               lastY &#x3D; y;</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_MOVE:</span><br><span class="line">               &#x2F;&#x2F;计算移动的距离</span><br><span class="line">               int offsetX &#x3D; x - lastX;</span><br><span class="line">               int offsetY &#x3D; y - lastY;</span><br><span class="line">               &#x2F;&#x2F;调用layout方法来重新放置它的位置</span><br><span class="line">               layout(getLeft()+offsetX, getTop()+offsetY,</span><br><span class="line">                       getRight()+offsetX , getBottom()+offsetY); &#x2F;&#x2F;layout()方法</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-offsetLeftAndRight-与offsetTopAndBottom"><a href="#3-2-2-offsetLeftAndRight-与offsetTopAndBottom" class="headerlink" title="3.2.2 offsetLeftAndRight()与offsetTopAndBottom()"></a>3.2.2 <code>offsetLeftAndRight()</code>与<code>offsetTopAndBottom()</code></h4><blockquote>
<p>思路：与<code>layout()</code>方法思路一样，不同的是<code>offsetLeftAndRight()</code>与<code>offsetTopAndBottom()</code>方法设置的是左右和上下的偏离值。</p>
</blockquote>
<p>使用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取到手指处的横坐标和纵坐标</span><br><span class="line">        int x &#x3D; (int) event.getX();</span><br><span class="line">        int y &#x3D; (int) event.getY();</span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                lastX &#x3D; x;</span><br><span class="line">                lastY &#x3D; y;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                &#x2F;&#x2F;计算移动的距离</span><br><span class="line">                int offsetX &#x3D; x - lastX;</span><br><span class="line">                int offsetY &#x3D; y - lastY;</span><br><span class="line">                &#x2F;&#x2F;对left和right进行偏移</span><br><span class="line">                offsetLeftAndRight(offsetX);  </span><br><span class="line">                &#x2F;&#x2F;对top和bottom进行偏移</span><br><span class="line">                offsetTopAndBottom(offsetY);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-2-3-LayoutParams-改变布局参数"><a href="#3-2-3-LayoutParams-改变布局参数" class="headerlink" title="3.2.3 LayoutParams(改变布局参数)"></a>3.2.3 <code>LayoutParams</code>(改变布局参数)</h5><blockquote>
<p>思路：<code>LayoutParams</code>主要保存了一个<code>View</code>的布局参数，可以通过<code>LayoutParams</code>来改变<code>View</code>的布局的参数从而达到了改变<code>View</code>的位置的效果。</p>
</blockquote>
<ul>
<li>使用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        &#x2F;&#x2F;获取到手指处的横坐标和纵坐标</span><br><span class="line">        int x &#x3D; (int) event.getX();</span><br><span class="line">        int y &#x3D; (int) event.getY();</span><br><span class="line">        switch (event.getAction()) &#123;</span><br><span class="line">            case MotionEvent.ACTION_DOWN:</span><br><span class="line">                lastX &#x3D; x;</span><br><span class="line">                lastY &#x3D; y;</span><br><span class="line">                break;</span><br><span class="line">            case MotionEvent.ACTION_MOVE:</span><br><span class="line">                &#x2F;&#x2F;计算移动的距离</span><br><span class="line">                int offsetX &#x3D; x - lastX;</span><br><span class="line">                int offsetY &#x3D; y - lastY;</span><br><span class="line">                LinearLayout.LayoutParams layoutParams&#x3D; (LinearLayout.LayoutParams) getLayoutParams();</span><br><span class="line">                layoutParams.leftMargin &#x3D; getLeft() + offsetX;</span><br><span class="line">                layoutParams.topMargin &#x3D; getTop() + offsetY;</span><br><span class="line">                setLayoutParams(layoutParams);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>​    父控件若是<code>LinearLayout</code>则按代码上所示，父控件若是<code>RelativeLayout</code>，则要使用<code>RelativeLayout.LayoutParams</code>，除了使用布局的<code>LayoutParams</code>外，也可以用<code>ViewGroup.MarginLayoutParams</code>来实现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;ViewGroup.MarginLayoutParams layoutParams &#x3D; (ViewGroup.MarginLayoutParams) getLayoutParams();</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="3-2-4-动画"><a href="#3-2-4-动画" class="headerlink" title="3.2.4 动画"></a>3.2.4 动画</h4><blockquote>
<p>思路：通过动画可以让一个<code>View</code>进行平移，而平移也就是一种滑动，主要操作的是<code>View</code>的<code>translationX</code>和<code>translationY</code>属性。</p>
<p><code>Android</code> 内有两种动画可以使用：View动画和属性动画。</p>
</blockquote>
<ul>
<li><p><code>View</code>动画使用：</p>
<p>1.在res目录新建anim文件夹并创建translate.xml：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayout.LayoutParams layoutParams&#x3D; (LinearLayout.LayoutParams) getLayoutParams();</span><br><span class="line">              layoutParams.leftMargin &#x3D; getLeft() + offsetX;</span><br><span class="line">              layoutParams.topMargin &#x3D; getTop() + offsetY;</span><br><span class="line">              setLayoutParams(layoutParams);</span><br></pre></td></tr></table></figure>

<p>​        2.在Java代码中引用：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mCustomView.setAnimation(AnimationUtils.loadAnimation(this, R.anim.translate));</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：<code>View</code>动画并不能改变<code>View</code>的位置参数。</p>
<p>如果对一个Button进行如上的平移动画操作，当Button平移300像素停留在当前位置时，我们点击这个Button并不会触发点击事件，但在我们点击这个Button的原始位置时却触发了点击事件。<strong>这就是补间动画和属性动画的区别</strong></p>
</blockquote>
<ul>
<li><p>属性动画使用：</p>
<p><code>CustomView</code>在1000毫秒内沿着X轴像右平移300像素:</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator.ofFloat(mCustomView,&quot;translationX&quot;,0,300).setDuration(1000).start();</span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-scrollTo-scrollBy"><a href="#3-2-5-scrollTo-scrollBy" class="headerlink" title="3.2.5 scrollTo/scrollBy"></a>3.2.5 <code>scrollTo</code>/<code>scrollBy</code></h4><blockquote>
<p>思路：<code>scollTo(x,y)</code>表示移动到一个具体的坐标点，而<code>scollBy(dx,dy)</code>则表示移动的增量为dx、dy。其中<code>scollBy</code>最终也是要调用<code>scollTo</code>的。<code>scollTo</code>、<code>scollBy</code>移动的是View的内容，如果在<code>ViewGroup</code>中使用则是移动他所有的子<code>View</code>。</p>
</blockquote>
<ul>
<li>使用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">       &#x2F;&#x2F;获取到手指处的横坐标和纵坐标</span><br><span class="line">       int x &#x3D; (int) event.getX();</span><br><span class="line">       int y &#x3D; (int) event.getY();</span><br><span class="line">       switch (event.getAction()) &#123;</span><br><span class="line">           case MotionEvent.ACTION_DOWN:</span><br><span class="line">               lastX &#x3D; x;</span><br><span class="line">               lastY &#x3D; y;</span><br><span class="line">               break;</span><br><span class="line">           case MotionEvent.ACTION_MOVE:</span><br><span class="line">               &#x2F;&#x2F;计算移动的距离</span><br><span class="line">               int offsetX &#x3D; x - lastX;</span><br><span class="line">               int offsetY &#x3D; y - lastY;</span><br><span class="line">               ((View)getParent()).scrollBy(-offsetX,-offsetY);</span><br><span class="line">               break;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="3-2-6-Scroller"><a href="#3-2-6-Scroller" class="headerlink" title="3.2.6 Scroller"></a>3.2.6 <code>Scroller</code></h4><blockquote>
<p><code>scollTo</code>/<code>scollBy</code>方法来进行滑动时，这个过程是瞬间完成的,使用<code>Scroller</code>来实现有过度效果的滑动，这个过程不是瞬间完成的，而是在一定的时间间隔完成的。<code>Scroller</code>本身是不能实现View的滑动的，它需要配合<code>View</code>的<code>computeScroll()</code>方法才能弹性滑动的效果。</p>
</blockquote>
<ul>
<li>使用：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void computeScroll() &#123;</span><br><span class="line">        super.computeScroll();</span><br><span class="line">        if(mScroller.computeScrollOffset())&#123;</span><br><span class="line">            ((View)getParent()).scrollTo(mScroller.getCurrX(),mScroller.getCurrY());</span><br><span class="line">            &#x2F;&#x2F;不断的重绘，重复调用computeScroll方法</span><br><span class="line">            PostInvalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;缓慢滚动到指定位置</span><br><span class="line">    public void smoothScrollTo(int destX,int destY)&#123;</span><br><span class="line">        int scrollX&#x3D;getScrollX();</span><br><span class="line">        int delta&#x3D;destX-scrollX;</span><br><span class="line">        &#x2F;&#x2F;1000秒内滑向destX</span><br><span class="line">        mScroller.startScroll(scrollX,0,delta,0,2000);</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在<code>View</code>类中调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用Scroll来进行平滑移动</span><br><span class="line">      mCustomView.smoothScrollTo(-400,0);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>源码分析</p>
<blockquote>
<p>当我们构造一个Scroller对象并调用它的startScroll方法时，startScroll保存了传递的几个参数</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> &#x2F;**</span><br><span class="line">   * @param startX 起点的横坐标</span><br><span class="line">   * @param startY 起点的纵坐标</span><br><span class="line">   * @param dx 水平滑动的距离</span><br><span class="line">   * @param dy 竖直滑动的距离</span><br><span class="line">   * @param duration 滑动时间</span><br><span class="line">   *&#x2F;</span><br><span class="line">public void startScroll(int startX, int startY, int dx, int dy, int duration) &#123;</span><br><span class="line">      mMode &#x3D; SCROLL_MODE;</span><br><span class="line">      mFinished &#x3D; false;</span><br><span class="line">      mDuration &#x3D; duration;</span><br><span class="line">      mStartTime &#x3D; AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">      mStartX &#x3D; startX;</span><br><span class="line">      mStartY &#x3D; startY;</span><br><span class="line">      mFinalX &#x3D; startX + dx;</span><br><span class="line">      mFinalY &#x3D; startY + dy;</span><br><span class="line">      mDeltaX &#x3D; dx;</span><br><span class="line">      mDeltaY &#x3D; dy;</span><br><span class="line">      mDurationReciprocal &#x3D; 1.0f &#x2F; (float) mDuration;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>Q1：在<code>startScroll</code>方法中，内部并没有做滑动相关的事，那么startScroll是如何让View滑动的？</p>
<blockquote>
<p>答：使用<code>invalidate</code>方法。<code>invalidate</code>方法会导致<code>View</code>重绘，重绘过程中<code>View</code>的<code>draw</code>方法中又会去调用<code>computeScroll</code>方法，本来<code>computeScroll</code>方法在<code>View</code>中是一个空实现，在上面的代码中我们已经添加代码，通过<code>scrollTo</code>方法实现滑动，接着使用<code>PostInvalidat</code>方法第二次重绘，如此反复，知道整个滑动过程结束。</p>
</blockquote>
<p>在<code>computeScroll</code>方法中有使用到<code>computeScrollOffset()</code>方法，下面看看这个方法的源码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean computeScrollOffset() &#123;</span><br><span class="line">        if (mFinished) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int timePassed &#x3D; (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</span><br><span class="line">    </span><br><span class="line">        if (timePassed &lt; mDuration) &#123;</span><br><span class="line">            switch (mMode) &#123;</span><br><span class="line">            case SCROLL_MODE:</span><br><span class="line">                final float x &#x3D; mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</span><br><span class="line">                mCurrX &#x3D; mStartX + Math.round(x * mDeltaX);</span><br><span class="line">                mCurrY &#x3D; mStartY + Math.round(x * mDeltaY);</span><br><span class="line">                break;</span><br><span class="line">  .......              </span><br></pre></td></tr></table></figure>

<blockquote>
<p>这个方法会根据时间的流逝计算当前的<code>scrollX</code>和<code>scrollY</code>的值。返回ture时表示滑动未结束，返回false则表示滑动已结束。</p>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925171402.png"></p>
</li>
</ul>
<h4 id="3-2-7-延时策略"><a href="#3-2-7-延时策略" class="headerlink" title="3.2.7 延时策略"></a>3.2.7 延时策略</h4><blockquote>
<p>核心思想：通过发送一系列延时消息从而达到一种渐进性效果。</p>
<p>使用：<code>Handle</code>/<code>View</code>的<code>postDelayed</code>/线程的<code>sleep</code>。</p>
<p>注意：无法精确定时，因为系统消息调度也需要时间。</p>
</blockquote>
<h2 id="四、事件分发机制"><a href="#四、事件分发机制" class="headerlink" title="四、事件分发机制"></a>四、事件分发机制</h2><blockquote>
<p>事件分发机制是View体系里学习的核心点，它是解决滑动冲突的理论基础，因此，学习好事件分发机制是非常重要的。</p>
<p>这一部分主要是我对知识的总结概括，看了之后还是对事件分发机制感到模糊的读者，推荐一篇详细的事件分发文章<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903894103883789#heading-0">学习 View 事件分发，就像外地人上了黑车！</a>。</p>
</blockquote>
<p>Q1:什么是点击事件的事件分发？</p>
<p>当一个点击事件<code>MotionEvent</code>产生以后，系统把这个事件传递给具体的<code>View</code>的过程，就是事件分发过程。</p>
<h3 id="4-1-主要方法"><a href="#4-1-主要方法" class="headerlink" title="4.1 主要方法"></a>4.1 主要方法</h3><ul>
<li><p><code>dispatchTouchEvent</code>：进行事件的<strong>分发</strong>（传递）。返回值是 <code>boolean</code> 类型，受当前<code>onTouchEvent</code>和<strong>下级view</strong>的<code>dispatchTouchEvent</code>影响</p>
</li>
<li><p><code>onInterceptTouchEvent</code>:对事件进行<strong>拦截</strong>。该方法只在<code>ViewGroup</code>中有，<code>View</code>（不包含 <code>ViewGroup</code>）是没有的。如果一旦拦截，则执行<code>ViewGroup</code>的<code>onTouchEvent</code>，在<code>ViewGroup</code>中处理事件，而不接着分发给View,且只调用一次，所以后面的事件都会交给<code>ViewGroup</code>处理。</p>
</li>
<li><p><code>onTouchEvent</code>：进行事件处理。</p>
</li>
</ul>
<p>三者关系的伪代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        boolean consume  &#x3D; false; &#x2F;&#x2F;boolean类型的值表示是否消费事件</span><br><span class="line">        if(onInterceptTouchEvent(event))&#123; &#x2F;&#x2F;当前View拦截了这个事件</span><br><span class="line">            consume &#x3D; onTouchEvent(event); &#x2F;&#x2F;执行当前View的onTouchEvent（）方法，是否消费由该返回值决定</span><br><span class="line">        &#125;else &#123;&#x2F;&#x2F;当前View没有拦截这个事件</span><br><span class="line">            consume  &#x3D; child.dispatchTouchEvent(event);  &#x2F;&#x2F;事件传递给下一层View的dispatchTouchEvent()方法，是否消费由下一层ViewdispatchTouchEvent()方法返回值决定</span><br><span class="line">        &#125;</span><br><span class="line">        return consume;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-事件分发的全流程"><a href="#4-2-事件分发的全流程" class="headerlink" title="4.2 事件分发的全流程"></a>4.2 事件分发的全流程</h3><p>Q2: View事件分发的本质是什么？</p>
<blockquote>
<p>View事件分发的本质是递归，点击事件自上而下分发的过程是“递”，消耗事件自下而上的过程是“归”。</p>
</blockquote>
<p>Q3： “递”和“归”的两个过程分别是什么？</p>
<p>当一个点击事件产生后，它的传递过程会遵循如下顺序：Activity-&gt;Window-&gt;ViewGroup-&gt;…-&gt;View。这个自上而下传递的过程就是“递“的过程。</p>
<p>当传递到具体的一个View后，这个View的<code>onTouchEvent</code>返回false，即不消耗这个事件，那么这个事件则会向上传递，假若所有的元素都不处理这事件，那么这个事件最终会传递给<code>Activity</code>处理，这个自下而上传递的过程就是“归”的过程。</p>
<blockquote>
<p>注意：</p>
<p>在“递”的过程中，<code>ViewGroup</code> 可以在当前层级，通过设置 <code>onInterceptTouchEvent</code> 方法返回 true，来拦截事件的下发，而直接步入“归”流程。</p>
<p>在 <code>ViewGroup</code> 可以拦截事件下发的同时，<code>child</code> 也可以通过 <code>getParent.requestDisallowInterceptTouchEvent</code> 方法，来阻止上一级的下发拦截。</p>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926222121.png"></p>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926222140.png"></p>
<blockquote>
<p>图取自<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903894103883789#heading-0">学习 View 事件分发，就像外地人上了黑车！</a></p>
</blockquote>
<p>总结：同样参考上面链接</p>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926180448.png"></p>
<h3 id="4-3-源码分析"><a href="#4-3-源码分析" class="headerlink" title="4.3 源码分析"></a>4.3 源码分析</h3><blockquote>
<p>事件分发的三个过程：</p>
<ol>
<li><code>Activity</code>对事件的分发</li>
<li>顶级<code>View</code>对事件的分发</li>
<li><code>View</code>对事件的处理</li>
</ol>
<p>这里不列出源码，仅画出流程图，需要查看源码的读者可查看《Android开发艺术探索》相应章节或者在编译器中查看。</p>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926204216.png"></p>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200926215641.png"></p>
<h2 id="五、滑动冲突"><a href="#五、滑动冲突" class="headerlink" title="五、滑动冲突"></a>五、滑动冲突</h2><blockquote>
<p>在使用滑动的过程中，假设一种情况，一个界面内外两层可以滑动，这个时候你滑动它，这个界面怎么判定你滑动的是内层还是外层？这个时候就会产生滑动冲突，所以在这个部分，我们一起来解决这个滑动冲突。</p>
</blockquote>
<h3 id="5-1-场景的滑动冲突场景"><a href="#5-1-场景的滑动冲突场景" class="headerlink" title="5.1  场景的滑动冲突场景"></a>5.1  场景的滑动冲突场景</h3><p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925225449.png"></p>
<ul>
<li>场景A：外部滑动与内部滑动不一致的滑动冲突，常见于常见于<code>ScrollView</code>和<code>Fragment</code>中<code>LisetView</code>的使用。</li>
<li>场景B：外部滑动与内部滑动一致的滑动冲突，可能出现在自定义<code>View</code>与<code>ListView</code>中，外部可以上下滑动，内部也可以上下滑动。</li>
<li>场景C：场景AB的嵌套。</li>
</ul>
<h3 id="5-2-处理规则"><a href="#5-2-处理规则" class="headerlink" title="5.2 处理规则"></a>5.2 处理规则</h3><ul>
<li><p>场景A的处理规则：当用户左右滑动时，让外部的View拦截点击事件，当用户上下滑动时，让内部的View拦截点击事件。</p>
<p>Q1：如何判断用户是左右滑动还是上下滑动</p>
<blockquote>
<p>利用水平偏移量和竖直方向的偏移量进行相减，用是否大于0来判断哪个偏移量大。若偏移量offsetX-offsetY&gt;0,可判断为水平滑动，这时可以由外部拦截，让它来处理点击事件。</p>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200925230015.png"></p>
</li>
<li><p>场景B的处理规则：需要根据业务逻辑来处理，，规定何时让外部View拦截事件何时由内部View拦截事件。</p>
</li>
<li><p>场景C的处理规则：同样需要从业务上找突破点</p>
</li>
</ul>
<h3 id="5-3-解决方法"><a href="#5-3-解决方法" class="headerlink" title="5.3 解决方法"></a>5.3 解决方法</h3><blockquote>
<ul>
<li><p>外部拦截法</p>
</li>
<li><p>内部拦截法</p>
</li>
</ul>
</blockquote>
<h4 id="5-3-1-外部拦截法"><a href="#5-3-1-外部拦截法" class="headerlink" title="5.3.1 外部拦截法"></a>5.3.1 外部拦截法</h4><blockquote>
<p>点击事件都先经过父容器的拦截处理，如果父容器需要就拦截，不需要此事件就不拦截。</p>
<p>方法：需要重写父容器的<code>onInterceptTouchEvent</code>方法，在内部做出相应的拦截。</p>
<p>注意：父容器一旦开始拦截任何一个事件，那么后续的事件都会交给它来处理。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;重写父容器的拦截方法</span><br><span class="line">public boolean onInterceptTouchEvent (MotionEvent event)&#123;</span><br><span class="line">    boolean intercepted &#x3D; false;</span><br><span class="line">    int x &#x3D; (int) event.getX();</span><br><span class="line">    int y &#x3D; (int) event.getY();</span><br><span class="line">    switch (event.getAction()) &#123;</span><br><span class="line">      case MotionEvent.ACTION_DOWN:&#x2F;&#x2F;对于ACTION_DOWN事件必须返回false，一旦拦截后续事件将不能传递给子View</span><br><span class="line">         intercepted &#x3D; false;</span><br><span class="line">         break;</span><br><span class="line">      case MotionEvent.ACTION_MOVE:&#x2F;&#x2F;对于ACTION_MOVE事件根据需要决定是否拦截</span><br><span class="line">         if (父容器需要当前事件） &#123;</span><br><span class="line">             intercepted &#x3D; true;</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">             intercepted &#x3D; flase;</span><br><span class="line">         &#125;</span><br><span class="line">         break;</span><br><span class="line">   &#125;</span><br><span class="line">      case MotionEvent.ACTION_UP:&#x2F;&#x2F;对于ACTION_UP事件必须返回false，一旦拦截子View的onClick事件将不会触发</span><br><span class="line">         intercepted &#x3D; false;</span><br><span class="line">         break;</span><br><span class="line">      default : break;</span><br><span class="line">   &#125;</span><br><span class="line">    mLastXIntercept &#x3D; x;</span><br><span class="line">    mLastYIntercept &#x3D; y;</span><br><span class="line">    return intercepted;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<h4 id="5-3-2-内部拦截法"><a href="#5-3-2-内部拦截法" class="headerlink" title="5.3.2 内部拦截法"></a>5.3.2 内部拦截法</h4><blockquote>
<p>父容器不拦截任何事件，所有事件都传递个给子元素，如果子元素需要此事件就直接消耗，否则交由父容器处理。</p>
<p>方法：需要配合<code>requestDisallowInterceptTouchEvent</code>方法。重写<code>子View</code>的<code>dispatchTouchEvent()</code></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public boolean dispatchTouchEvent ( MotionEvent event ) &#123;</span><br><span class="line">  int x &#x3D; (int) event.getX();</span><br><span class="line">  int y &#x3D; (int) event.getY();</span><br><span class="line"></span><br><span class="line">  switch (event.getAction) &#123;</span><br><span class="line">      case MotionEvent.ACTION_DOWN:</span><br><span class="line">         parent.requestDisallowInterceptTouchEvent(true);&#x2F;&#x2F;为true表示禁止父容器拦截</span><br><span class="line">         break;</span><br><span class="line">      case MotionEvent.ACTION_MOVE:</span><br><span class="line">         int deltaX &#x3D; x - mLastX;</span><br><span class="line">         int deltaY &#x3D; y - mLastY;</span><br><span class="line">         if (父容器需要此类点击事件) &#123;</span><br><span class="line">             parent.requestDisallowInterceptTouchEvent(false);&#x2F;&#x2F;为fasle表示允许父容器拦截</span><br><span class="line">         &#125;</span><br><span class="line">         break;</span><br><span class="line">      case MotionEvent.ACTION_UP:</span><br><span class="line">         break;</span><br><span class="line">      default :</span><br><span class="line">         break;        </span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line">  mLastX &#x3D; x;</span><br><span class="line">  mLastY &#x3D; y;</span><br><span class="line">  return super.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：除子容器需要做处理外，父容器也要<strong>默认拦截除了<code>ACTION_DOWN</code>以外的其他事件</strong>，这样当子容器调用<code>parent.requestDisallowInterceptTouchEvent(false)</code>方法时，父元素才能继续拦截所需的事件。</p>
<p>因此，<code>父View</code>需要重写<code>onInterceptTouchEvent()</code>：</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean onInterceptTouchEvent (MotionEvent event) &#123;</span><br><span class="line"> int action &#x3D; event.getAction();</span><br><span class="line"> if(action &#x3D;&#x3D; MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">     return false;</span><br><span class="line"> &#125; else &#123;</span><br><span class="line">     return true;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Q1：为什么父容器不能拦截ACTION_DOWN事件？</p>
<blockquote>
<p>由于该事件并不受<code>FLAG_DISALLOW_INTERCEPT</code>（由<code>requestDisallowInterceptTouchEvent</code>方法设置）标记位控制，所以一旦父容器拦截了该事件，那么所有的事件都<strong>不会传递给子View</strong>，内部拦截法也就失效了。</p>
</blockquote>
<hr>
<p>参考自：</p>
<ul>
<li><p>《Android开发艺术探索》</p>
</li>
<li><p>《Android进阶之光》</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904070365315080#heading-19">进阶之路 | 奇妙的View之旅</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903894103883789#heading-0">学习 View 事件分发，就像外地人上了黑车！</a></p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/12/IPC%E6%9C%BA%E5%88%B6/" rel="prev" title="浅谈IPC|Binder">
      <i class="fa fa-chevron-left"></i> 浅谈IPC|Binder
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/27/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/" rel="next" title="View的工作原理">
      View的工作原理 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81%E5%AD%A6%E4%B9%A0%E8%84%91%E5%9B%BE"><span class="nav-number">1.</span> <span class="nav-text">一、学习脑图</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81View%E5%9F%BA%E7%A1%80"><span class="nav-number">2.</span> <span class="nav-text">二、View基础</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E4%BB%80%E4%B9%88%E6%98%AFView%EF%BC%9F"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 什么是View？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-View%E7%9A%84%E4%BD%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 View的位置参数</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-Android%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">2.2.1 Android坐标系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-View%E5%9D%90%E6%A0%87%E7%B3%BB"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">2.2.2 View坐标系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-3-View%E7%9A%84%E8%A7%A6%E6%8E%A7"><span class="nav-number">2.2.0.3.</span> <span class="nav-text">2.2.3  View的触控</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-3-1-MotionEvent"><span class="nav-number">2.2.0.3.1.</span> <span class="nav-text">2.2.3.1 MotionEvent</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-3-2-TouchSlop"><span class="nav-number">2.2.0.3.2.</span> <span class="nav-text">2.2.3.2 TouchSlop</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-3-3-VelocityTracker"><span class="nav-number">2.2.0.3.3.</span> <span class="nav-text">2.2.3.3 VelocityTracker</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-3-4-GestureDetector"><span class="nav-number">2.2.0.3.4.</span> <span class="nav-text">2.2.3.4 GestureDetector</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-2-3-5-Scroller"><span class="nav-number">2.2.0.3.5.</span> <span class="nav-text">2.2.3.5 Scroller</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81View%E7%9A%84%E6%BB%91%E5%8A%A8"><span class="nav-number">3.</span> <span class="nav-text">三、View的滑动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-View%E6%BB%91%E5%8A%A8%E7%9A%847%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 View滑动的7种方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-layout"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.2.1 layout()</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-offsetLeftAndRight-%E4%B8%8EoffsetTopAndBottom"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.2.2 offsetLeftAndRight()与offsetTopAndBottom()</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-2-3-LayoutParams-%E6%94%B9%E5%8F%98%E5%B8%83%E5%B1%80%E5%8F%82%E6%95%B0"><span class="nav-number">3.1.2.1.</span> <span class="nav-text">3.2.3 LayoutParams(改变布局参数)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-%E5%8A%A8%E7%94%BB"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.2.4 动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-5-scrollTo-scrollBy"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.2.5 scrollTo&#x2F;scrollBy</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-6-Scroller"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.2.6 Scroller</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-7-%E5%BB%B6%E6%97%B6%E7%AD%96%E7%95%A5"><span class="nav-number">3.1.6.</span> <span class="nav-text">3.2.7 延时策略</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="nav-number">4.</span> <span class="nav-text">四、事件分发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%B8%BB%E8%A6%81%E6%96%B9%E6%B3%95"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 主要方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E7%9A%84%E5%85%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 事件分发的全流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 源码分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81"><span class="nav-number">5.</span> <span class="nav-text">五、滑动冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%9C%BA%E6%99%AF%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81%E5%9C%BA%E6%99%AF"><span class="nav-number">5.1.</span> <span class="nav-text">5.1  场景的滑动冲突场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E5%A4%84%E7%90%86%E8%A7%84%E5%88%99"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 处理规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 解决方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-1-%E5%A4%96%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 外部拦截法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-2-%E5%86%85%E9%83%A8%E6%8B%A6%E6%88%AA%E6%B3%95"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 内部拦截法</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuki"
      src="/images/suoda.jpg">
  <p class="site-author-name" itemprop="name">Yuki</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">17</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Yuki-r" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yuki-r" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuki</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
