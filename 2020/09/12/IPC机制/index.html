<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言  IPC是什么？ 为什么要学IPC？ 怎么进行IPC？   下面是我这篇博文的学习脑图，方便读者更快的找到自己想要了解的知识点。">
<meta property="og:type" content="article">
<meta property="og:title" content="浅谈IPC|Binder">
<meta property="og:url" content="http://example.com/2020/09/12/IPC%E6%9C%BA%E5%88%B6/index.html">
<meta property="og:site_name" content="Yuki-r Blog">
<meta property="og:description" content="前言  IPC是什么？ 为什么要学IPC？ 怎么进行IPC？   下面是我这篇博文的学习脑图，方便读者更快的找到自己想要了解的知识点。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912213714.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200910205858.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912153003.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912154138.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912165339.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912194412.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912201809.png">
<meta property="og:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912212556.png">
<meta property="article:published_time" content="2020-09-12T14:10:24.000Z">
<meta property="article:modified_time" content="2020-09-12T14:13:17.676Z">
<meta property="article:author" content="Yuki">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912213714.png">

<link rel="canonical" href="http://example.com/2020/09/12/IPC%E6%9C%BA%E5%88%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>浅谈IPC|Binder | Yuki-r Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Yuki-r Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/09/12/IPC%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/suoda.jpg">
      <meta itemprop="name" content="Yuki">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Yuki-r Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          浅谈IPC|Binder
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2020-09-12 22:10:24 / 修改时间：22:13:17" itemprop="dateCreated datePublished" datetime="2020-09-12T22:10:24+08:00">2020-09-12</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<ul>
<li><code>IPC</code>是什么？</li>
<li>为什么要学<code>IPC</code>？</li>
<li>怎么进行<code>IPC</code>？</li>
</ul>
</blockquote>
<p>下面是我这篇博文的学习脑图，方便读者更快的找到自己想要了解的知识点。</p>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912213714.png"></p>
<a id="more"></a>

<h2 id="一、IPC简介"><a href="#一、IPC简介" class="headerlink" title="一、IPC简介"></a>一、<code>IPC</code>简介</h2><h2 id="1-1什么是IPC"><a href="#1-1什么是IPC" class="headerlink" title="1.1什么是IPC"></a>1.1什么是<code>IPC</code></h2><p><code>IPC</code>是Inter-Process Communication的缩写，含义为<strong>进程间通信或者跨进程通信</strong>，是<strong>指两个进程之间进行数据交换的过程</strong>。</p>
<p>看到这里，需要先了解一下进程、线程以及它们的关系。</p>
<blockquote>
<ul>
<li><p>进程：一般指一个执行单元，在PC和移动设备上指一个<strong>程序</strong>或<strong>应用</strong>。</p>
</li>
<li><p>线程：CPU调度的最小单元。线程是一种有限的系统资源。</p>
<p>二者之间的关系：</p>
<p>一个<strong>进程</strong>可包含多个<strong>线程</strong>，即一个应用程序上可以同时执行多个任务。</p>
<p>注意：不可在主线程做大量耗时操作，会导致<strong>ANR</strong>（应用无响应）。</p>
</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200910205858.png"></p>
<p><code>IPC</code>不是Android中所独有的，任何一个操作系统都需要有相应的<code>IPC</code>机制，Binder是Android中最有特色的进程间通信方式。</p>
<h2 id="1-2为什么要进行IPC"><a href="#1-2为什么要进行IPC" class="headerlink" title="1.2为什么要进行IPC"></a>1.2为什么要进行<code>IPC</code></h2><p>进程间通信的必要性</p>
<blockquote>
<p>​    所有运行在不同进程的四大组件，只要它们之间需要通过内存在共享数据，都会共享失败。这是由于Android为每个应用分配了独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这会导致在不同的虚拟机中访问同一个类的对象会产生多份副本。</p>
</blockquote>
<h2 id="1-3怎么进行IPC"><a href="#1-3怎么进行IPC" class="headerlink" title="1.3怎么进行IPC"></a>1.3怎么进行<code>IPC</code></h2><blockquote>
<p>使用Bundle、文件共享、<code>Messenger</code>、<code>AIDL</code>、<code>ContentProvider</code>、Socket。</p>
</blockquote>
<h2 id="二、Android-中的多进程模式"><a href="#二、Android-中的多进程模式" class="headerlink" title="二、Android 中的多进程模式"></a>二、Android 中的多进程模式</h2><h3 id="2-1开启进程"><a href="#2-1开启进程" class="headerlink" title="2.1开启进程"></a>2.1开启进程</h3><blockquote>
<ul>
<li>（常规）在<code>AndroidMenifest</code>中给四大组件指定属性<code>android:process</code>。</li>
<li>（不常规）通过<code>JNI</code>在native层fork一个新的进程。</li>
</ul>
</blockquote>
<p>进程名的默认规则：</p>
<p>默认进程：</p>
<ul>
<li>没有指定该属性则运行在默认进程，其进程名就是<strong>包名</strong>。</li>
</ul>
<p>以“：”开头的进程：</p>
<ul>
<li>省略包名，如<code>android:process=&quot;:remote&quot;</code>，表示进程名为<code>com.example.myapplication:remote</code>。</li>
<li>属于当前应用的<strong>私有进程</strong>，其他进程的组件不能和他跑在同一进程中。</li>
</ul>
<p>完整命名的进程：</p>
<ul>
<li>如<code>android:process=&quot;com.example.myapplication.remote&quot;</code>。</li>
<li>属于<strong>全局进程</strong>，其他应用可以通过<code>**ShareUID**</code>方式和他跑在用一个进程中。</li>
</ul>
<blockquote>
<p><code>UID</code>: Android系统会为每个应用分配一个唯一的<code>UID</code>，具有相同的<code>UID</code>才能共享数据。</p>
<p>两个应用通过<code>ShareUID</code>跑在同一个进程中的条件：具有相同的<code>ShareUID</code>和签名。</p>
<ul>
<li>满足上述条件的两个应用，无论是否跑在同一进程，它们可共享data目录，组件信息。</li>
<li>若跑在同一进程，它们除了可共享data目录、组件信息，还可共享内存数据。它们就像是一个应用的两个部分。</li>
</ul>
</blockquote>
<h3 id="2-2多进程的运行机制"><a href="#2-2多进程的运行机制" class="headerlink" title="2.2多进程的运行机制"></a>2.2多进程的运行机制</h3><p>Android为每一个进程分配了一个独立的虚拟机，不同虚拟机在内存分配上有<strong>不同的地址空间</strong>，这也导致了不同虚拟机中访问同一个对象会产生<strong>多份副本</strong>。</p>
<p>一般来说使用多进程会带来以下四个方面的问题：</p>
<blockquote>
<ul>
<li><p>静态变量和单例模式失效       原因：不同虚拟机中访问同一个对象会产生<strong>多份副本</strong>。</p>
</li>
<li><p>线程同步机制失效                  原因：内存不同，线程无法同步。</p>
</li>
<li><p><code>SharedPreference</code>的可靠性下降      原因：底层是通过读写XML文件实现的，发生并发问题。</p>
</li>
<li><p>Application多次创建-                         原因：Android系统会为新的进程分配独立虚拟机，相当于应用重新启动了一次。</p>
</li>
</ul>
</blockquote>
<p>为了解决这些问题，可以采用跨进程通信方法，通过Intent，共享文件和<code>SharedPreferences</code>，<code>Messenger</code>、<code>AIDL</code>和<code>Socket</code>等。</p>
<h2 id="三、IPC基础概念"><a href="#三、IPC基础概念" class="headerlink" title="三、IPC基础概念"></a>三、<code>IPC</code>基础概念</h2><p>在了解以下三种接口使用前，需要先了解一下什么是序列化和反序列化。</p>
<p>1.什么是序列化？</p>
<blockquote>
<p>含义：序列化表示将一个对象转换成<strong>可存储或可传输</strong>的状态。序列化后的对象可以在网络上进行传输，也可以存储到本地。</p>
<p>场景：需要通过<code>Intent</code>和<code>Binder</code>等传输<strong>类对象</strong>就必须完成对象的序列化过程。</p>
<p>两种方式：实现<code>Serializable</code>/<code>Parcelable</code>接口。</p>
</blockquote>
<p>2.什么是反序列化？</p>
<p>把字节序列恢复为对象的过程称为对象的反序列化，与序列化相反。</p>
<h3 id="3-1-Serializable接口"><a href="#3-1-Serializable接口" class="headerlink" title="3.1 Serializable接口"></a>3.1 <code>Serializable</code>接口</h3><p><code>Serializable</code>是Java所提供的一个序列化接口，是一个空接口，为对象提供标准的序列化和反序列化操作。</p>
<blockquote>
<ul>
<li><p>用法：实体类实现<code>Serializable</code>接口，声明<code>serialVesionUID</code>。</p>
</li>
<li><p>注意：<code>serialVesionUID</code>非必需，但是不声明会对反序列化有影响。</p>
</li>
</ul>
<p>​            <code>serialVesionUID</code>与当前类的<code>serialVesionUID</code>相同才能被正常反序列化。</p>
<p>​            <code>serialVesionUID</code>可以系统配置/手动修改。            </p>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User实体类实现Serializable接口；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> UserId;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span> </span>&#123;</span><br><span class="line">        UserId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getSerialVersionUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UserId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        UserId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMale</span><span class="params">(<span class="keyword">boolean</span> male)</span> </span>&#123;</span><br><span class="line">        isMale = male;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">   User user = <span class="keyword">new</span> User(<span class="number">1</span>,<span class="string">&quot;Yuki&quot;</span>,<span class="keyword">true</span>);</span><br><span class="line">   ObjectOutputStream outputStream;</span><br><span class="line"></span><br><span class="line">   &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           outputStream = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;cache.txt&quot;</span>));</span><br><span class="line">   <span class="comment">//反序列化过程</span></span><br><span class="line">   ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;cache.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">           User newUser = (User)in.readObject();</span><br><span class="line">           in.close();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-Parcelable接口"><a href="#3-2-Parcelable接口" class="headerlink" title="3.2 Parcelable接口"></a>3.2 <code>Parcelable</code>接口</h3><blockquote>
<p>用法：</p>
<ul>
<li><p>实体类实现<code>Parcelable</code>接口</p>
</li>
<li><p>内容描述</p>
</li>
<li><p>序列化</p>
</li>
<li><p>反序列化</p>
</li>
</ul>
</blockquote>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//User实体类实现Parcelable；</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> UserId;</span><br><span class="line">    <span class="keyword">public</span> String userName;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isMale;</span><br><span class="line"><span class="comment">//    public Book book;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(<span class="keyword">int</span> userId, String userName, <span class="keyword">boolean</span> isMale)</span> </span>&#123;</span><br><span class="line">        UserId = userId;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">        <span class="keyword">this</span>.isMale = isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">User</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        UserId = in.readInt();</span><br><span class="line">        userName = in.readString();</span><br><span class="line">        isMale = in.readByte() != <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        book = in.readParcelable(Thread.currentThread().getContextClassLoader());</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;User&gt; CREATOR = <span class="keyword">new</span> Creator&lt;User&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User(in);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> User[] newArray(<span class="keyword">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> User[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UserId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">        UserId = userId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMale</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isMale;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMale</span><span class="params">(<span class="keyword">boolean</span> male)</span> </span>&#123;</span><br><span class="line">        isMale = male;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//内容描述</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//序列化</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel dest, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        dest.writeInt(UserId);</span><br><span class="line">        dest.writeString(userName);</span><br><span class="line">        dest.writeByte((<span class="keyword">byte</span>) (isMale ? <span class="number">1</span> : <span class="number">0</span>));</span><br><span class="line"><span class="comment">//        dest.writeParcelable(book,0);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Parcelable</code>方法说明</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">功能</th>
<th align="center">标记位</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>createFromParcel(Parcel in)</code></td>
<td align="center">从序列化后的对象中创建原始对象</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>newArray(int size)</code></td>
<td align="center">创建指定长度的原始对象数组</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>writeToParcel(Parcel dest, int flags)</code></td>
<td align="center">将当前对象写入序列化结构中，其中flags标识有两种值：0或者1，为1时标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有的情况都为0</td>
<td align="center"><code>PARCELABLE_WRITE_RETURN_VALUE</code></td>
</tr>
<tr>
<td align="center">User(Parcel in)</td>
<td align="center">从序列化后的对象中创建原始对象</td>
<td align="center"></td>
</tr>
<tr>
<td align="center"><code>describeContents</code></td>
<td align="center">返回当前对象的内容描述，如果含有文件描述符，返回1，否则返回0，几乎所有的情况都返回0</td>
<td align="center"><code>CONTENTS_FILE_DESCRIPTOR</code></td>
</tr>
</tbody></table>
<p><code>Serializable</code>和<code>Parcelable</code>比较</p>
<table>
<thead>
<tr>
<th align="center"><code>Serializable</code></th>
<th align="center"><code>Parcelable</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">Java序列化接口</td>
<td align="center">Android序列化接口</td>
</tr>
<tr>
<td align="center">使用简单</td>
<td align="center">使用较麻烦</td>
</tr>
<tr>
<td align="center">效率低</td>
<td align="center">效率高</td>
</tr>
</tbody></table>
<h3 id="3-3-Binder"><a href="#3-3-Binder" class="headerlink" title="3.3 Binder"></a>3.3 Binder</h3><h4 id="3-3-1-Binder是什么？"><a href="#3-3-1-Binder是什么？" class="headerlink" title="3.3.1 Binder是什么？"></a>3.3.1 Binder是什么？</h4><blockquote>
<ul>
<li>直观上：Android 的一个类，实现了<code>IBinder</code>接口。</li>
<li><code>**IPC</code> 角度：Android中的一种跨进程通信**。</li>
<li>实现方式角度：一种虚拟的物理设备。</li>
<li>Android <code>Framework</code>角度：：<code>ServiceManager</code>连接各种<code>Manager</code>（<code>ActivityManager</code>、<code>WindowManager</code>等）的桥梁。</li>
<li>Android应用层角度：客户端和服务端进行通信的媒介。</li>
</ul>
</blockquote>
<h4 id="3-3-2-为什么是Binder？"><a href="#3-3-2-为什么是Binder？" class="headerlink" title="3.3.2 为什么是Binder？"></a>3.3.2 为什么是Binder？</h4><p>Android系统是基于Linux内核的，Linux已经提供了管道、消息队列、内存共享和<code>Socket</code>等<code>IPC</code>机制，为什么Android还要提供<code>Binder</code>来实现<code>IPC</code>？</p>
<table>
<thead>
<tr>
<th align="left">优势</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">性能</td>
<td>只需要一次数据拷贝，性能上仅次于共享内存</td>
</tr>
<tr>
<td align="left">稳定性</td>
<td>基于C/S架构，职责明确，架构清晰，稳定性好</td>
</tr>
<tr>
<td align="left">安全性</td>
<td>为每个<code>APP</code>分配<code>UID</code>，进程的<code>UID</code>事鉴别进程身份的重要标志</td>
</tr>
</tbody></table>
<h4 id="3-3-3-Binder-IPC底层通信原理"><a href="#3-3-3-Binder-IPC底层通信原理" class="headerlink" title="3.3.3 Binder IPC底层通信原理"></a>3.3.3 <code>Binder</code> <code>IPC</code>底层通信原理</h4><h5 id="3-3-3-1-其他IPC机制完成一次进程间通信是怎么样的"><a href="#3-3-3-1-其他IPC机制完成一次进程间通信是怎么样的" class="headerlink" title="3.3.3.1.其他IPC机制完成一次进程间通信是怎么样的?"></a>3.3.3.1.其他<code>IPC</code>机制完成一次进程间通信是怎么样的?</h5><blockquote>
<p>​    在不同的进程之间，消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 <code>copy*from*user()</code> 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 <code>copy*to*user</code>() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。</p>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912153003.png"></p>
<h5 id="3-3-3-2-Binder-IPC完成一次进程间通信又是怎么样的？"><a href="#3-3-3-2-Binder-IPC完成一次进程间通信又是怎么样的？" class="headerlink" title="3.3.3.2 Binder IPC完成一次进程间通信又是怎么样的？"></a>3.3.3.2 <code>Binder</code> <code>IPC</code>完成一次进程间通信又是怎么样的？</h5><blockquote>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 <code>copy*from*user</code>() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912154138.png"></p>
<p>各种<code>IPC</code>方式数据拷贝次数</p>
<table>
<thead>
<tr>
<th><code>IPC</code></th>
<th>数据拷贝次数</th>
</tr>
</thead>
<tbody><tr>
<td>共享内存</td>
<td>0</td>
</tr>
<tr>
<td><code>Binder</code></td>
<td>1</td>
</tr>
<tr>
<td>消息队列/管道/<code>Socket</code></td>
<td>2</td>
</tr>
</tbody></table>
<h4 id="3-3-4-Binder通信过程"><a href="#3-3-4-Binder通信过程" class="headerlink" title="3.3.4 Binder通信过程"></a>3.3.4 Binder通信过程</h4><blockquote>
<p><code>Binder</code>框架定义了四个角色：<code>Server</code>，<code>Client</code>，<code>ServiceManager</code>以及Binder驱动。其中<code>Server</code>，<code>Client</code>，<code>ServiceManager</code>运行于用户空间，驱动运行于内核空间。这四个角色的关系和互联网类似：<code>Server</code>是服务器，<code>Client</code>是客户终端，<code>ServiceManager</code>是域名服务器（<code>DNS</code>），驱动是路由器。</p>
</blockquote>
<ol>
<li><p>首先，一个进程使用 <code>BINDER*SET*CONTEXT_MGR</code> 命令通过 <code>Binder</code> 驱动将自己注册成为 <code>ServiceManager</code>；</p>
</li>
<li><p><code>Server</code> 通过驱动向 <code>ServiceManager</code> 中注册 <code>Binder</code>（<code>Server</code> 中的 <code>Binder</code> 实体），表明可以对外提供服务。驱动为这个 <code>Binder</code> 创建位于内核中的实体节点以及 <code>ServiceManager</code> 对实体的引用，将名字以及新建的引用打包传给 <code>ServiceManager</code>，<code>ServiceManger</code> 将其填入查找表。</p>
</li>
<li><p><code>Client</code> 通过名字，在 <code>Binder</code> 驱动的帮助下从 <code>ServiceManager</code> 中获取到对 <code>Binder</code> 实体的引用，通过这个引用就能实现和 <code>Server</code> 进程的通信。</p>
<p>这里参考自：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></p>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912165339.png"></p>
</li>
</ol>
<p>问：<strong>当服务端进程异常终止的话，造成<code>Binder</code>死亡的话，怎么办？</strong></p>
<p>在客户端绑定远程服务成功后，给<code>Binder</code>设置<strong>死亡代理</strong>，当<code>Binder</code>死亡的时候，我们会收到通知，从而重新发起连接请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private IBinder.DeathRecipient mDeathRecipient &#x3D; new IBinder.DeathRecipient()&#123;</span><br><span class="line">@Override</span><br><span class="line">public void binderDied()&#123;</span><br><span class="line">if(mBookManager &#x3D;&#x3D; null)&#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">mBookManager.asBinder().unlinkToDeath(mDeathRecipient,0);</span><br><span class="line">mBookManager &#x3D; null;</span><br><span class="line">&#x2F;&#x2F; TODO：这里重新绑定远程Service</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mService &#x3D; IBookManager.Stub.asInterface(binder);</span><br><span class="line">binder.linkToDeath(mDeathRecipient,0);</span><br></pre></td></tr></table></figure>







<h2 id="四、Android中的IPC模式"><a href="#四、Android中的IPC模式" class="headerlink" title="四、Android中的IPC模式"></a>四、Android中的<code>IPC</code>模式</h2><h3 id="4-1-Bundle"><a href="#4-1-Bundle" class="headerlink" title="4.1  Bundle"></a>4.1 <code> Bundle</code></h3><p>概念：由于<code>Bundle</code>实现了<code>Parcelable</code>接口，可以方便的在不同进程间传输。</p>
<blockquote>
<ul>
<li>范围：<code>Activity</code>、<code>Service</code>、<code>Receiver</code>间传递。</li>
<li>使用：通过<code>Intent</code>发送。</li>
</ul>
</blockquote>
<p>扩展使用：A进程要启动B进程并把在A进程计算完的数据传递给B进程，如何把不支持Bundle的数据由A进程传入B中？</p>
<p>答：将原本在A进程的计算任务转移到B进程的后台Service中去执行。通过<code>Intent</code>启动B进程的一个<code>Service</code>，让计算任务在Service完成，计算完成                            后再去启动目标组件，并把数据传递给目标组件。</p>
<h3 id="4-2-文件共享"><a href="#4-2-文件共享" class="headerlink" title="4.2 文件共享"></a>4.2 文件共享</h3><p>概念：两个进程通过读/写同一个文件来交换数据。</p>
<blockquote>
<ul>
<li>文件范围：对文件格式没有具体要求。</li>
<li>局限性：并发读/写。</li>
</ul>
</blockquote>
<h3 id="4-3-Messenger"><a href="#4-3-Messenger" class="headerlink" title="4.3  Messenger"></a>4.3 <code> Messenger</code></h3><p>概念：可以在不同进程中传递<code>Message</code>对象，把需要传递的数据放进对象中。</p>
<blockquote>
<ul>
<li><p>底层实现：轻量级的 <code>IPC</code> 方案，它的底层实现是 <code>AIDL</code>。</p>
</li>
<li><p>实现<code>Message</code></p>
<p>1.服务端进程</p>
<ul>
<li>创建一个<code>Service</code>处理客户端连接请求</li>
<li>创建一个<code>Handle</code>并通过它创建一个Messenger对象</li>
<li>在<code>Service</code>的<code>onBind</code>返回这个对象的底层Binder</li>
</ul>
<p>2.客户端进程</p>
<ul>
<li>绑定服务端的<code>Service</code></li>
<li>用服务端返回的<code>IBinder</code>对象创建一个<code>Messenger</code>（客户端——&gt;服务端）</li>
<li>在客户端创建一个<code>Handler</code>并由此创建一个<code>Messenger</code>，并通过<code>Message</code>的**<code>replyTo</code>字段**传递给服务器端进程。服务端通过读取<code>Message</code>得到<code>Messenger</code>对象，进而向客户端进程传递数据。（客户端 &lt;——&gt;服务端）</li>
</ul>
</li>
</ul>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Messenger 服务端代码</span><br><span class="line">public class MessengerService extends Service &#123;</span><br><span class="line">    private static final String TAG &#x3D; &quot;MessengerService&quot;;</span><br><span class="line">    private final Messenger messenger &#x3D; new Messenger(new MessengerHandler());</span><br><span class="line">    &#x2F;&#x2F;处理客户端发送的消息</span><br><span class="line">    private static class MessengerHandler extends Handler&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(@NonNull Message msg) &#123;</span><br><span class="line">            switch (msg.what)&#123;</span><br><span class="line">                   case 1:</span><br><span class="line">                    Log.i(&quot;TAG&quot;,&quot; &quot;+msg.getData().getString(&quot;msg&quot;));</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    break;</span><br><span class="line">            &#125;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @Nullable</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return messenger.getBinder();    &#x2F;&#x2F;返回它的Binder对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;service android:name&#x3D;&quot;.MessengerService&quot;</span><br><span class="line">           android:process&#x3D;&quot;:remote&quot;&#x2F;&gt;   &#x2F;&#x2F;注册Service</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;客户端代码</span><br><span class="line">public class MessengerActivity extends AppCompatActivity &#123;</span><br><span class="line"></span><br><span class="line">    private Messenger mService;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        &#x2F;&#x2F;绑定服务</span><br><span class="line">        Intent intent &#x3D; new Intent(this,MessengerService.class);</span><br><span class="line">        bindService(intent,mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection mConnection &#x3D; new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            mService &#x3D; new Messenger(service); &#x2F;&#x2F;用服务端返回的IBinder对象创建一个Messenger对象</span><br><span class="line">            Message msg &#x3D; Message.obtain(null,1);</span><br><span class="line">            Bundle data &#x3D; new Bundle();</span><br><span class="line">            data.putString(&quot;msg&quot;,&quot;Client&quot;);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            try &#123;</span><br><span class="line">                mService.send(msg);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        unbindService(mConnection);</span><br><span class="line">        super.onDestroy();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912194412.png"></p>
<h3 id="4-4-使用AIDL"><a href="#4-4-使用AIDL" class="headerlink" title="4.4  使用AIDL"></a>4.4  使用<code>AIDL</code></h3><blockquote>
<p><code>AIDL</code> 是 <code>Android Interface Definition Language</code> 的缩写，意思是<code>Android</code>接口定义语言，用于让某个<code>Service</code>与多个应用程序组件之间进行跨进程通信，从而可以实现多个应用程序共享同一个<code>Service</code>的功能。其使用可以简单的概括为服务端和客户端，类似于<code>Socket</code> 一样，服务端服务于所有客户端，支持一对多服务。</p>
</blockquote>
<h4 id="4-4-1-Messenger和AIDL比较"><a href="#4-4-1-Messenger和AIDL比较" class="headerlink" title="4.4.1 Messenger和AIDL比较"></a>4.4.1 <code>Messenger</code>和<code>AIDL</code>比较</h4><p><code>Messenger</code>缺点：串行方式处理消息，无法并发处理。</p>
<p><code>AIDL</code>：可以并发处理请求。</p>
<blockquote>
<p><code>AIDL</code>通信流程</p>
<ul>
<li>服务端<ul>
<li>创建<code>Service</code>监听客户端请求</li>
<li>创建<code>AIDL</code>文件</li>
<li>在<code>AIDL</code>文件中申明暴露给客户端的接口</li>
<li>在<code>Service</code>实现这个<code>AIDL</code>接口</li>
</ul>
</li>
<li>客户端<ul>
<li>绑定服务端的Service</li>
<li>将服务端返回的Binder对象转成<code>AIDL</code>接口所属的类型</li>
<li>调用<code>AIDL</code>方法</li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="4-4-2AIDL能够支持哪些数据类型？"><a href="#4-4-2AIDL能够支持哪些数据类型？" class="headerlink" title="4.4.2AIDL能够支持哪些数据类型？"></a>4.4.2<code>AIDL</code>能够支持哪些数据类型？</h4><p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912201809.png"></p>
<p><strong>注意</strong>：除了基本数据类型，其它类型的参数必须标上方向：<code>in、out或inout</code>，用于表示在跨进程通信中数据的流向。</p>
<h4 id="4-4-3-关键类和关键方法"><a href="#4-4-3-关键类和关键方法" class="headerlink" title="4.4.3 关键类和关键方法"></a>4.4.3 关键类和关键方法</h4><ul>
<li><strong><code>AIDL</code>接口</strong>：继承<code>IInterface</code>。</li>
<li><strong><code>Stub</code>类</strong>：<code>Binder</code>的实现类，服务端通过这个类来提供服务。</li>
<li><strong><code>Proxy</code>类</strong>：服务器的本地代理，客户端通过这个类调用服务器的方法。</li>
<li><code>asInterface()</code>：客户端调用，将服务端的返回的<code>Binder</code>对象，转换成客户端所需要的<code>AIDL</code>接口类型对象。</li>
</ul>
<blockquote>
<p>返回对象：</p>
<ul>
<li>若客户端和服务端位于同一进程，则直接返回<code>Stub</code>对象本身；</li>
<li>否则，返回的是系统封装后的<code>Stub.proxy</code>对象。</li>
</ul>
</blockquote>
<ul>
<li><code>asBinder()</code>：返回代理<code>Proxy</code>的<code>Binder</code>对象。</li>
<li><code>onTransact()</code>：运行服务端的<code>Binder</code>线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。</li>
<li><code>transact()</code>：运行在客户端，当客户端发起远程请求的同时将当前线程挂起。之后调用服务端的<code>onTransact()</code>直到远程请求返回，当前线程才继续执行。</li>
</ul>
<h4 id="4-4-4-产生ANR的情形"><a href="#4-4-4-产生ANR的情形" class="headerlink" title="4.4.4 产生ANR的情形"></a>4.4.4 产生<code>ANR</code>的情形</h4><ul>
<li><p>客户端：</p>
<ul>
<li>调用服务端的方法是运行在服务端的<code>Binder</code>线程池中，若<strong>主线程</strong>所调用的方法里执行了较<strong>耗时</strong>的任务，同时会导致客户端线程长时间阻塞，易导致客户端<code>ANR</code>。</li>
<li>在<code>onServiceConnected()</code>和<code>onServiceDisconnected()</code>里直接调用服务端的耗时方法，易导致客户端<code>ANR</code>。</li>
</ul>
</li>
<li><p>服务端：</p>
<ul>
<li>服务端的方法本身就运行在服务端的**<code>Binder</code>线程<strong>中，可在其中执行耗时操作，而</strong>无需再开启子线程**。</li>
<li><strong>回调客户端<code>Listener</code>的方法</strong>是运行在客户端的<code>Binder</code>线程中，若所调用的方法里执行了较<strong>耗时</strong>的任务，易导致服务端<code>ANR</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>解决客户端频繁调用服务器方法导致性能极大损耗的办法：实现<strong>观察者模式</strong>。</p>
<p>即当客户端关注的数据发生变化时，再让服务端通知客户端去做相应的业务处理。</p>
</blockquote>
<h4 id="4-4-5解注册失败的问题"><a href="#4-4-5解注册失败的问题" class="headerlink" title="4.4.5解注册失败的问题"></a>4.4.5解注册失败的问题</h4><ul>
<li>原因: <code>Binder</code>进行对象传输实际是通过序列化和反序列化进行，即<code>Binder</code>会把客户端传递过来的对象<strong>重新转化</strong>并生成一个新的对象，虽然在注册和解注册的过程中使用的是同一个客户端传递的对象，但经过<code>Binder</code>传到服务端后会生成两个不同的对象。另外，多次跨进程传输的同一个客户端对象会在服务端生成<strong>不同</strong>的对象，但它们在底层的<code>Binder</code>对象是<strong>相同</strong>的。</li>
<li>解决办法：当客户端解注册的时候，遍历服务端所有的<code>Listener</code>，找到和解注册<code>Listener</code>具有相同的<code>Binder</code>对象的服务端<code>Listener</code>，删掉即可。</li>
</ul>
<blockquote>
<p>需要用到<code>RemoteCallBackList</code>：<code>Android</code>系统专门提供的用于删除跨进程<code>listener</code>的接口。其内部自动实现了线程同步的功能。</p>
</blockquote>
<h3 id="4-5-使用ContentProvider"><a href="#4-5-使用ContentProvider" class="headerlink" title="4.5 使用ContentProvider"></a>4.5 使用<code>ContentProvider</code></h3><h4 id="4-5-1-什么是ContentProvider？"><a href="#4-5-1-什么是ContentProvider？" class="headerlink" title="4.5.1 什么是ContentProvider？"></a>4.5.1 什么是<code>ContentProvider</code>？</h4><p><code>ContentProvider</code>Android中提供的专门用于不同应用间进行数据共享的方法，它天生就适合进程间通信。</p>
<h4 id="4-5-2-如何自定义一个ContentProvider？"><a href="#4-5-2-如何自定义一个ContentProvider？" class="headerlink" title="4.5.2 如何自定义一个ContentProvider？"></a>4.5.2 如何自定义一个<code>ContentProvider</code>？</h4><ul>
<li>用一个实体类继承<code>ContentProvider</code>。</li>
<li>实现<code>onCreate</code>、<code>query</code>、<code>update</code>、<code>insert</code>、<code>delete</code>和<code>getType</code>等六种抽象方法。、</li>
</ul>
<p>注意：</p>
<p>除了<code>onCreate()</code>运行在UI线程中，其他的<code>query()</code>、<code>update()</code>、<code>insert()</code>、<code>delete()</code>和<code>getType()</code>都运行在<code>Binder</code>线程池中。</p>
<p><code>CRUD</code>四大操作存在多线程并发访问，要注意在方法内部要做好线程同步。</p>
<p>一个<code>SQLiteDatabase</code>内部对数据库的操作有同步处理，但多个<code>SQLiteDatabase</code>之间无法同步。 </p>
<h3 id="4-6-使用Socket"><a href="#4-6-使用Socket" class="headerlink" title="4.6 使用Socket"></a>4.6 使用<code>Socket</code></h3><h4 id="4-6-1-什么是Socket？"><a href="#4-6-1-什么是Socket？" class="headerlink" title="4.6.1 什么是Socket？"></a>4.6.1 什么是<code>Socket</code>？</h4><p><code>Socket</code>也称为“套接字”，是网络通信的概念。分为流式套接字和用户数据报套接字两种。</p>
<blockquote>
<ul>
<li>流套接字：基于<code>TCP</code>协议，采用流的方式提供可靠的字节流服务。</li>
<li>数据流套接字：基于<code>UDP</code>协议，采用数据报文提供数据打包发送的服务。</li>
</ul>
</blockquote>
<h4 id="4-6-2-怎么实现Socket通信？"><a href="#4-6-2-怎么实现Socket通信？" class="headerlink" title="4.6.2 怎么实现Socket通信？"></a>4.6.2 怎么实现<code>Socket</code>通信？</h4><ul>
<li><p>服务端：</p>
<ul>
<li>创建一个<code>Service</code>，在线程中建立<code>TCP</code>服务、监听相应的端口等待客户端连接请求；</li>
<li>与客户端连接时，会生成新的<code>Socket</code>对象，利用它可与客户端进行数据传输；</li>
<li>与客户端断开连接时，关闭相应的<code>Socket</code>并结束线程。</li>
</ul>
</li>
<li><p>客户端：</p>
<ul>
<li>开启一个线程、通过<code>Socket</code>发出连接请求；</li>
<li>连接成功后，读取服务端消息；</li>
<li>断开连接，关闭<code>Socket</code>。</li>
</ul>
</li>
</ul>
<h2 id="五、IPC方式"><a href="#五、IPC方式" class="headerlink" title="五、IPC方式"></a>五、<code>IPC</code>方式</h2><p>各种<code>IPC</code>方式的优缺点比较：</p>
<table>
<thead>
<tr>
<th align="center">名称</th>
<th align="center">优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>Bundle</code></td>
<td align="center">简单易用</td>
<td>只能传输Bundle支持的数据类型</td>
<td>四大组件间的进程间通信</td>
</tr>
<tr>
<td align="center">文件共享</td>
<td align="center">简单易用</td>
<td>不适合高并发场景，无法做到进程间的即时通信</td>
<td>无并发访问，交换简单数据且实时性不高</td>
</tr>
<tr>
<td align="center"><code>AIDL</code></td>
<td align="center">支持一对多并发和实时通信</td>
<td>使用稍复杂，需要处理线程同步</td>
<td>一对多且有<code>RPC</code>需求</td>
</tr>
<tr>
<td align="center"><code>Messenger</code></td>
<td align="center">支持一对多串行通信</td>
<td>不能很好处理高并发，不支持<code>RPC</code>，只能传输Bundle支持的数据类型</td>
<td>低并发的一对多</td>
</tr>
<tr>
<td align="center"><code>ContentProvider</code></td>
<td align="center">支持一对多并发数据共享</td>
<td>可理解为受约束的<code>AIDL</code></td>
<td>一对多进程间数据共享</td>
</tr>
<tr>
<td align="center">Socket</td>
<td align="center">支持一对多并发数据共享</td>
<td>实现细节繁琐</td>
<td>网络数据交换</td>
</tr>
</tbody></table>
<h2 id="六、Binder连接池"><a href="#六、Binder连接池" class="headerlink" title="六、Binder连接池"></a>六、<code>Binder</code>连接池</h2><h4 id="6-1-典型的AIDL使用流程"><a href="#6-1-典型的AIDL使用流程" class="headerlink" title="6.1 典型的AIDL使用流程"></a>6.1 典型的<code>AIDL</code>使用流程</h4><blockquote>
<ul>
<li>创建一个<code>Service</code>和一个<code>AIDL</code>接口</li>
<li>创建一个类继承自<code>AIDL</code>接口中的<code>Stub</code>类并实现<code>Stub</code>中的抽象方法</li>
<li>在Service的<code>onBind</code>方法中返回这个类的对象</li>
</ul>
</blockquote>
<h4 id="6-2-当有多个不同的业务需要使用AIDL来进行通信，该怎么处理？"><a href="#6-2-当有多个不同的业务需要使用AIDL来进行通信，该怎么处理？" class="headerlink" title="6.2 当有多个不同的业务需要使用AIDL来进行通信，该怎么处理？"></a>6.2 当有多个不同的业务需要使用<code>AIDL</code>来进行通信，该怎么处理？</h4><p>可以将所有的<code>AIDL</code>放在同一个<code>Service</code>中去管理，它的工作机制是这样的：</p>
<p>每个业务模块创建自己的<code>AIDL</code>接口，向服务端提供自己的唯一标识和对应的Binder对象。对服务端来说，只需一个<code>Service</code>，服务端提供一个<code>queryBinder</code>接口，可以根据业务模块特征返回相应的Binder对象。Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程<code>Service</code>去执行，避免重复创建<code>Service</code>。</p>
<blockquote>
<p>实现方式：</p>
<ul>
<li>为每个业务模块创建<code>AIDL</code>接口并具体实现。</li>
<li>为<code>Binder</code>连接池创建<code>AIDL</code>接口<code>IBinderPool.aidl</code>并具体实现。</li>
<li>远程服务<code>BinderPoolService</code>的实现，在<code>onBind()</code>返回实例化的<code>IBinderPool</code>实现类对象。</li>
<li><code>Binder</code>连接池的具体实现，来绑定远程服务。</li>
<li>客户端的调用。</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/yuki-r/blog-image/raw/master/img/20200912212556.png"></p>
<p>本文参考：</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/35519585">写给 Android 应用工程师的 Binder 原理剖析</a></p>
</li>
<li><p>《Android开发艺术探索》</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844904070361137159#heading-7">进阶之路 | 奇妙的 IPC 之旅</a></p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/universus/article/details/6211589">Android Bander设计与实现 - 设计篇</a></p>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/11/%E5%8D%8E%E4%B8%BA%E9%B8%BF%E8%92%99%E7%B3%BB%E7%BB%9F%EF%BC%8C%E8%BF%90%E8%A1%8C%E7%AC%AC%E4%B8%80%E4%B8%AA%E2%80%9Chello%20world%E2%80%9D/" rel="prev" title="鸿蒙OS，运行第一个“hello world”">
      <i class="fa fa-chevron-left"></i> 鸿蒙OS，运行第一个“hello world”
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/26/View%E4%BD%93%E7%B3%BB%E8%AF%A6%E8%A7%A3/" rel="next" title="View体系详解">
      View体系详解 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81IPC%E7%AE%80%E4%BB%8B"><span class="nav-number">2.</span> <span class="nav-text">一、IPC简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1%E4%BB%80%E4%B9%88%E6%98%AFIPC"><span class="nav-number">3.</span> <span class="nav-text">1.1什么是IPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%9B%E8%A1%8CIPC"><span class="nav-number">4.</span> <span class="nav-text">1.2为什么要进行IPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3%E6%80%8E%E4%B9%88%E8%BF%9B%E8%A1%8CIPC"><span class="nav-number">5.</span> <span class="nav-text">1.3怎么进行IPC</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81Android-%E4%B8%AD%E7%9A%84%E5%A4%9A%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">二、Android 中的多进程模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1%E5%BC%80%E5%90%AF%E8%BF%9B%E7%A8%8B"><span class="nav-number">6.1.</span> <span class="nav-text">2.1开启进程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="nav-number">6.2.</span> <span class="nav-text">2.2多进程的运行机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81IPC%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="nav-number">7.</span> <span class="nav-text">三、IPC基础概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Serializable%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.1.</span> <span class="nav-text">3.1 Serializable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Parcelable%E6%8E%A5%E5%8F%A3"><span class="nav-number">7.2.</span> <span class="nav-text">3.2 Parcelable接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Binder"><span class="nav-number">7.3.</span> <span class="nav-text">3.3 Binder</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-1-Binder%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">7.3.1.</span> <span class="nav-text">3.3.1 Binder是什么？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AFBinder%EF%BC%9F"><span class="nav-number">7.3.2.</span> <span class="nav-text">3.3.2 为什么是Binder？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-3-Binder-IPC%E5%BA%95%E5%B1%82%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86"><span class="nav-number">7.3.3.</span> <span class="nav-text">3.3.3 Binder IPC底层通信原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-1-%E5%85%B6%E4%BB%96IPC%E6%9C%BA%E5%88%B6%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84"><span class="nav-number">7.3.3.1.</span> <span class="nav-text">3.3.3.1.其他IPC机制完成一次进程间通信是怎么样的?</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-3-2-Binder-IPC%E5%AE%8C%E6%88%90%E4%B8%80%E6%AC%A1%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8F%88%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="nav-number">7.3.3.2.</span> <span class="nav-text">3.3.3.2 Binder IPC完成一次进程间通信又是怎么样的？</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-4-Binder%E9%80%9A%E4%BF%A1%E8%BF%87%E7%A8%8B"><span class="nav-number">7.3.4.</span> <span class="nav-text">3.3.4 Binder通信过程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81Android%E4%B8%AD%E7%9A%84IPC%E6%A8%A1%E5%BC%8F"><span class="nav-number">8.</span> <span class="nav-text">四、Android中的IPC模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Bundle"><span class="nav-number">8.1.</span> <span class="nav-text">4.1  Bundle</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB"><span class="nav-number">8.2.</span> <span class="nav-text">4.2 文件共享</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-Messenger"><span class="nav-number">8.3.</span> <span class="nav-text">4.3  Messenger</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E4%BD%BF%E7%94%A8AIDL"><span class="nav-number">8.4.</span> <span class="nav-text">4.4  使用AIDL</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-1-Messenger%E5%92%8CAIDL%E6%AF%94%E8%BE%83"><span class="nav-number">8.4.1.</span> <span class="nav-text">4.4.1 Messenger和AIDL比较</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-2AIDL%E8%83%BD%E5%A4%9F%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%9F"><span class="nav-number">8.4.2.</span> <span class="nav-text">4.4.2AIDL能够支持哪些数据类型？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-3-%E5%85%B3%E9%94%AE%E7%B1%BB%E5%92%8C%E5%85%B3%E9%94%AE%E6%96%B9%E6%B3%95"><span class="nav-number">8.4.3.</span> <span class="nav-text">4.4.3 关键类和关键方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-4-%E4%BA%A7%E7%94%9FANR%E7%9A%84%E6%83%85%E5%BD%A2"><span class="nav-number">8.4.4.</span> <span class="nav-text">4.4.4 产生ANR的情形</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-5%E8%A7%A3%E6%B3%A8%E5%86%8C%E5%A4%B1%E8%B4%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-number">8.4.5.</span> <span class="nav-text">4.4.5解注册失败的问题</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E4%BD%BF%E7%94%A8ContentProvider"><span class="nav-number">8.5.</span> <span class="nav-text">4.5 使用ContentProvider</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-1-%E4%BB%80%E4%B9%88%E6%98%AFContentProvider%EF%BC%9F"><span class="nav-number">8.5.1.</span> <span class="nav-text">4.5.1 什么是ContentProvider？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-5-2-%E5%A6%82%E4%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAContentProvider%EF%BC%9F"><span class="nav-number">8.5.2.</span> <span class="nav-text">4.5.2 如何自定义一个ContentProvider？</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E4%BD%BF%E7%94%A8Socket"><span class="nav-number">8.6.</span> <span class="nav-text">4.6 使用Socket</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-1-%E4%BB%80%E4%B9%88%E6%98%AFSocket%EF%BC%9F"><span class="nav-number">8.6.1.</span> <span class="nav-text">4.6.1 什么是Socket？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-6-2-%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0Socket%E9%80%9A%E4%BF%A1%EF%BC%9F"><span class="nav-number">8.6.2.</span> <span class="nav-text">4.6.2 怎么实现Socket通信？</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81IPC%E6%96%B9%E5%BC%8F"><span class="nav-number">9.</span> <span class="nav-text">五、IPC方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%AD%E3%80%81Binder%E8%BF%9E%E6%8E%A5%E6%B1%A0"><span class="nav-number">10.</span> <span class="nav-text">六、Binder连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E5%85%B8%E5%9E%8B%E7%9A%84AIDL%E4%BD%BF%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">10.0.1.</span> <span class="nav-text">6.1 典型的AIDL使用流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%BD%93%E6%9C%89%E5%A4%9A%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E4%B8%9A%E5%8A%A1%E9%9C%80%E8%A6%81%E4%BD%BF%E7%94%A8AIDL%E6%9D%A5%E8%BF%9B%E8%A1%8C%E9%80%9A%E4%BF%A1%EF%BC%8C%E8%AF%A5%E6%80%8E%E4%B9%88%E5%A4%84%E7%90%86%EF%BC%9F"><span class="nav-number">10.0.2.</span> <span class="nav-text">6.2 当有多个不同的业务需要使用AIDL来进行通信，该怎么处理？</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Yuki"
      src="/images/suoda.jpg">
  <p class="site-author-name" itemprop="name">Yuki</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/Yuki-r" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;Yuki-r" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Yuki</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
